@page "/"
@rendermode InteractiveServer
@using System.Text.Json
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS

<div class="conversation-container">
    <div class="status-bar">
        <div class="connection-status @(isReady ? "connected" : (isChecking ? "connecting" : "disconnected"))">
            @if (isChecking)
            {
                <span class="spinner"></span>
            }
            else
            {
                <span class="status-dot"></span>
            }
            @(isReady ? "Ready" : (isChecking ? "Checking backend..." : "Backend unavailable"))
        </div>
        <div class="voice-selector">
            <label>Voice:</label>
            <select @bind="selectedVoice">
                <option value="en-carter">Carter</option>
                <option value="en-davis">Davis</option>
                <option value="en-emma">Emma</option>
                <option value="en-frank">Frank</option>
                <option value="en-grace">Grace</option>
                <option value="en-mike">Mike</option>
            </select>
        </div>
    </div>

    <div class="chat-area" @ref="chatArea">
        @foreach (var msg in messages)
        {
            <div class="chat-bubble @(msg.IsUser ? "user-bubble" : "ai-bubble")">
                <div class="bubble-label">@(msg.IsUser ? "You" : "AI")</div>
                <div class="bubble-text">@msg.Text</div>
                @if (!msg.IsUser && msg.HasAudio)
                {
                    <button class="play-btn" @onclick="() => PlayAudio(msg.AudioBytes!)">
                        üîä Play
                    </button>
                }
            </div>
        }
        @if (!string.IsNullOrEmpty(statusText))
        {
            <div class="status-indicator">
                <span class="status-pulse"></span> @statusText
            </div>
        }
    </div>

    <div class="controls-area">
        <button class="push-to-talk @(isRecording ? "recording" : "")"
                @onmousedown="StartRecording"
                @onmouseup="StopRecording"
                @ontouchstart="StartRecording"
                @ontouchend="StopRecording"
                disabled="@(!isReady || isBusy)">
            <div class="mic-icon">üé§</div>
            <div class="mic-label">@(isRecording ? "Release to Send" : (isBusy ? "Processing..." : "Hold to Talk"))</div>
        </button>

        <button class="test-btn" @onclick="TestConnection">
            üîå Test Connection
        </button>

        @if (messages.Count > 0)
        {
            <button class="test-btn reset-btn" @onclick="ResetConversation">
                üîÑ Reset
            </button>
        }
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-toast" @onclick="() => errorMessage = null">
            ‚ö†Ô∏è @errorMessage
        </div>
    }

    <div class="debug-console">
        <div class="console-header">Debug Console</div>
        <div class="console-logs" @ref="consoleArea">
            @foreach (var log in debugLogs)
            {
                <div class="log-entry">@log</div>
            }
        </div>
    </div>
</div>

<style>
    .debug-console {
        margin-top: 20px;
        background: #1e1e1e;
        color: #00ff00;
        font-family: monospace;
        font-size: 12px;
        border-radius: 8px;
        padding: 10px;
        height: 150px;
        display: flex;
        flex-direction: column;
        border: 1px solid #333;
    }
    .console-header {
        border-bottom: 1px solid #333;
        padding-bottom: 5px;
        margin-bottom: 5px;
        color: #888;
        font-weight: bold;
    }
    .console-logs {
        overflow-y: auto;
        flex-grow: 1;
    }
    .log-entry {
        margin-bottom: 2px;
        word-break: break-all;
    }
    .connection-status.connecting {
        color: #ffcc00;
    }
    .spinner {
        display: inline-block;
        width: 10px;
        height: 10px;
        border: 2px solid rgba(255, 204, 0, 0.3);
        border-radius: 50%;
        border-top-color: #ffcc00;
        animation: spin 1s ease-in-out infinite;
        margin-right: 8px;
    }
    @@keyframes spin {
        to { transform: rotate(360deg); }
    }
    .test-btn {
        margin-left: 15px;
        padding: 10px 20px;
        background: #333;
        color: white;
        border: 1px solid #555;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.2s;
    }
    .test-btn:hover {
        background: #444;
    }
    .reset-btn {
        background: #444;
    }
</style>

@code {
    private bool isReady;
    private bool isChecking;
    private bool isRecording;
    private bool isBusy;
    private string? statusText;
    private string? errorMessage;
    private string selectedVoice = "en-emma";
    private string sessionId = Guid.NewGuid().ToString();
    private List<ChatMessage> messages = new();
    private ElementReference chatArea;
    private ElementReference consoleArea;
    private List<string> debugLogs = new();

    private void LogDebug(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
        debugLogs.Add($"[{timestamp}] {message}");
        InvokeAsync(StateHasChanged);
        try
        {
            _ = JS.InvokeVoidAsync("eval", "setTimeout(() => { var el = document.querySelector('.console-logs'); if(el) el.scrollTop = el.scrollHeight; }, 50)");
        }
        catch { }
    }

    private class ChatMessage
    {
        public string Text { get; set; } = "";
        public bool IsUser { get; set; }
        public bool HasAudio { get; set; }
        public byte[]? AudioBytes { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            LogDebug("Component rendered, checking backend...");
            await CheckBackendReady();
        }
        await JS.InvokeVoidAsync("eval", "document.querySelector('.chat-area')?.scrollTo(0, document.querySelector('.chat-area')?.scrollHeight)");
    }

    private async Task CheckBackendReady()
    {
        const int maxRetries = 20;
        int attempt = 0;
        while (attempt < maxRetries)
        {
            isChecking = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                var client = HttpClientFactory.CreateClient("backend");
                LogDebug($"Checking /api/ready (attempt {attempt + 1})...");
                var resp = await client.GetAsync("/api/ready");
                if (resp.IsSuccessStatusCode)
                {
                    var body = await resp.Content.ReadAsStringAsync();
                    using var doc = JsonDocument.Parse(body);
                    isReady = doc.RootElement.TryGetProperty("ready", out var readyProp) && readyProp.GetBoolean();
                    LogDebug($"Backend ready: {isReady}");
                    isChecking = false;
                    await InvokeAsync(StateHasChanged);
                    return;
                }
                LogDebug($"Backend not ready: {(int)resp.StatusCode}");
            }
            catch (Exception ex)
            {
                LogDebug($"Backend check failed: {ex.Message}");
            }
            isReady = false;
            errorMessage = "Cannot reach backend. Retrying in 5s...";
            await InvokeAsync(StateHasChanged);
            await Task.Delay(5000);
            attempt++;
        }
        isChecking = false;
        errorMessage = "Backend unavailable after multiple retries. Please refresh the page.";
        await InvokeAsync(StateHasChanged);
    }

    private async Task TestConnection()
    {
        LogDebug("--- Starting HTTP Connection Test ---");
        try
        {
            var client = HttpClientFactory.CreateClient("backend");

            LogDebug("1. Testing Root Endpoint (/)");
            var rootResponse = await client.GetAsync("/");
            LogDebug($"   Status: {(int)rootResponse.StatusCode} {rootResponse.StatusCode}");
            var rootContent = await rootResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {rootContent}");

            LogDebug("2. Testing Ping Endpoint (/api/test/ping)");
            var pingResponse = await client.GetAsync("/api/test/ping");
            LogDebug($"   Status: {(int)pingResponse.StatusCode} {pingResponse.StatusCode}");
            var pingContent = await pingResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {pingContent}");

            LogDebug("3. Testing Health Endpoint (/api/health)");
            var healthResponse = await client.GetAsync("/api/health");
            LogDebug($"   Status: {(int)healthResponse.StatusCode} {healthResponse.StatusCode}");
            var healthContent = await healthResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {healthContent}");

            LogDebug("--- HTTP Connection Test Complete ---");
        }
        catch (Exception ex)
        {
            LogDebug($"HTTP Test Failed: {ex.GetType().Name} - {ex.Message}");
            if (ex.InnerException != null)
                LogDebug($"Inner exception: {ex.InnerException.Message}");
        }
    }

    private async Task StartRecording()
    {
        if (!isReady || isRecording || isBusy) return;
        try
        {
            await JS.InvokeVoidAsync("audioInterop.startRecording");
            isRecording = true;
            statusText = "Listening...";
        }
        catch (Exception ex)
        {
            errorMessage = $"Microphone access denied: {ex.Message}";
        }
    }

    private async Task StopRecording()
    {
        if (!isRecording) return;
        try
        {
            isRecording = false;
            isBusy = true;
            statusText = "Processing...";
            StateHasChanged();

            var audioData = await JS.InvokeAsync<byte[]>("audioInterop.stopRecording");
            if (audioData?.Length > 0)
            {
                await SendConversationRequest(audioData);
            }
            else
            {
                statusText = null;
                isBusy = false;
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to process audio: {ex.Message}";
            statusText = null;
            isBusy = false;
        }
    }

    private async Task SendConversationRequest(byte[] audioData)
    {
        try
        {
            LogDebug($"Sending {audioData.Length} bytes of audio to /api/conversation");
            var client = HttpClientFactory.CreateClient("backend");

            using var content = new MultipartFormDataContent();
            content.Add(new ByteArrayContent(audioData)
            {
                Headers = { ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("audio/webm") }
            }, "audio", "audio.webm");
            content.Add(new StringContent(selectedVoice), "voice_id");
            content.Add(new StringContent(sessionId), "session_id");

            statusText = "Thinking...";
            await InvokeAsync(StateHasChanged);

            var response = await client.PostAsync("/api/conversation", content);
            var body = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                errorMessage = $"Backend error: {(int)response.StatusCode} - {body}";
                LogDebug($"Conversation request failed: {(int)response.StatusCode} {body}");
                return;
            }

            LogDebug($"Response received ({body.Length} chars)");
            using var doc = JsonDocument.Parse(body);
            var root = doc.RootElement;

            if (root.TryGetProperty("error", out var errProp))
            {
                errorMessage = errProp.GetString();
                LogDebug($"Backend error: {errorMessage}");
                return;
            }

            var transcript = root.TryGetProperty("transcript", out var tp) ? tp.GetString() ?? "" : "";
            var responseText = root.TryGetProperty("response_text", out var rp) ? rp.GetString() ?? "" : "";
            var audioBase64 = root.TryGetProperty("audio_base64", out var ap) ? ap.GetString() ?? "" : "";

            messages.Add(new ChatMessage { Text = transcript, IsUser = true });

            byte[]? wavBytes = null;
            if (!string.IsNullOrEmpty(audioBase64))
            {
                wavBytes = Convert.FromBase64String(audioBase64);
            }

            messages.Add(new ChatMessage
            {
                Text = responseText,
                IsUser = false,
                HasAudio = wavBytes is { Length: > 0 },
                AudioBytes = wavBytes,
            });

            statusText = "Speaking...";
            await InvokeAsync(StateHasChanged);

            if (wavBytes is { Length: > 0 })
            {
                await JS.InvokeVoidAsync("audioInterop.playAudio", wavBytes);
            }

            statusText = null;
            LogDebug("Conversation turn complete.");
        }
        catch (Exception ex)
        {
            errorMessage = $"Conversation failed: {ex.Message}";
            LogDebug($"Exception: {ex.GetType().Name} - {ex.Message}");
        }
        finally
        {
            isBusy = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ResetConversation()
    {
        try
        {
            var client = HttpClientFactory.CreateClient("backend");
            await client.DeleteAsync($"/api/conversation/{sessionId}");
        }
        catch (Exception ex)
        {
            LogDebug($"Reset session delete failed (non-critical): {ex.Message}");
        }
        sessionId = Guid.NewGuid().ToString();
        messages.Clear();
        statusText = null;
        errorMessage = null;
        LogDebug("Conversation reset.");
    }

    private async Task PlayAudio(byte[] audioBytes)
    {
        await JS.InvokeVoidAsync("audioInterop.playAudio", audioBytes);
    }
}
