@page "/"
@rendermode InteractiveServer
@using System.Net.WebSockets
@using System.Text
@using System.Text.Json
@inject IHttpClientFactory HttpClientFactory
@inject IConfiguration Configuration
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="conversation-container">
    <div class="status-bar">
        <div class="connection-status @(isConnected ? "connected" : (isConnecting ? "connecting" : "disconnected"))">
            @if (isConnecting)
            {
                <span class="spinner"></span>
            }
            else
            {
                <span class="status-dot"></span>
            }
            @(isConnected ? "Connected" : (isConnecting ? "Connecting..." : "Disconnected"))
        </div>
        <div class="voice-selector">
            <label>Voice:</label>
            <select @bind="selectedVoice">
                <option value="en-carter">Carter</option>
                <option value="en-davis">Davis</option>
                <option value="en-emma">Emma</option>
                <option value="en-frank">Frank</option>
                <option value="en-grace">Grace</option>
                <option value="en-mike">Mike</option>
            </select>
        </div>
    </div>

    <div class="chat-area" @ref="chatArea">
        @foreach (var msg in messages)
        {
            <div class="chat-bubble @(msg.IsUser ? "user-bubble" : "ai-bubble")">
                <div class="bubble-label">@(msg.IsUser ? "You" : "AI")</div>
                <div class="bubble-text">@msg.Text</div>
                @if (!msg.IsUser && msg.HasAudio)
                {
                    <button class="play-btn" @onclick="() => PlayAudio(msg.AudioBytes!)">
                        üîä Play
                    </button>
                }
            </div>
        }
        @if (!string.IsNullOrEmpty(statusText))
        {
            <div class="status-indicator">
                <span class="status-pulse"></span> @statusText
            </div>
        }
    </div>

    <div class="controls-area">
        <button class="push-to-talk @(isRecording ? "recording" : "")"
                @onmousedown="StartRecording"
                @onmouseup="StopRecording"
                @ontouchstart="StartRecording"
                @ontouchend="StopRecording"
                disabled="@(!isConnected)">
            <div class="mic-icon">üé§</div>
            <div class="mic-label">@(isRecording ? "Release to Send" : "Hold to Talk")</div>
        </button>
        
        <button class="test-btn" @onclick="TestConnection">
            üîå Test Connection
        </button>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="error-toast" @onclick="() => errorMessage = null">
            ‚ö†Ô∏è @errorMessage
        </div>
    }

    <div class="debug-console">
        <div class="console-header">Debug Console</div>
        <div class="console-logs" @ref="consoleArea">
            @foreach (var log in debugLogs)
            {
                <div class="log-entry">@log</div>
            }
        </div>
    </div>
</div>

<style>
    .debug-console {
        margin-top: 20px;
        background: #1e1e1e;
        color: #00ff00;
        font-family: monospace;
        font-size: 12px;
        border-radius: 8px;
        padding: 10px;
        height: 150px;
        display: flex;
        flex-direction: column;
        border: 1px solid #333;
    }
    .console-header {
        border-bottom: 1px solid #333;
        padding-bottom: 5px;
        margin-bottom: 5px;
        color: #888;
        font-weight: bold;
    }
    .console-logs {
        overflow-y: auto;
        flex-grow: 1;
    }
    .log-entry {
        margin-bottom: 2px;
        word-break: break-all;
    }
    .connection-status.connecting {
        color: #ffcc00;
    }
    .spinner {
        display: inline-block;
        width: 10px;
        height: 10px;
        border: 2px solid rgba(255, 204, 0, 0.3);
        border-radius: 50%;
        border-top-color: #ffcc00;
        animation: spin 1s ease-in-out infinite;
        margin-right: 8px;
    }
    @@keyframes spin {
        to { transform: rotate(360deg); }
    }
    .test-btn {
        margin-left: 15px;
        padding: 10px 20px;
        background: #333;
        color: white;
        border: 1px solid #555;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: background 0.2s;
    }
    .test-btn:hover {
        background: #444;
    }
</style>

@code {
    private ClientWebSocket? webSocket;
    private CancellationTokenSource? cts;
    private bool isConnected;
    private bool isConnecting;
    private bool isRecording;
    private string? statusText;
    private string? errorMessage;
    private string selectedVoice = "en-emma";
    private List<ChatMessage> messages = new();
    private ElementReference chatArea;
    private ElementReference consoleArea;
    private List<byte> pendingAudioBytes = new();
    private List<string> debugLogs = new();

    private void LogDebug(string message)
    {
        var timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
        debugLogs.Add($"[{timestamp}] {message}");
        InvokeAsync(StateHasChanged);
        try
        {
            _ = JS.InvokeVoidAsync("eval", "setTimeout(() => { var el = document.querySelector('.console-logs'); if(el) el.scrollTop = el.scrollHeight; }, 50)");
        }
        catch { }
    }

    private class ChatMessage
    {
        public string Text { get; set; } = "";
        public bool IsUser { get; set; }
        public bool HasAudio { get; set; }
        public byte[]? AudioBytes { get; set; }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            LogDebug("Component rendered, initiating connection...");
            await ConnectWebSocket();
        }
        // Scroll chat to bottom
        await JS.InvokeVoidAsync("eval", "document.querySelector('.chat-area')?.scrollTo(0, document.querySelector('.chat-area')?.scrollHeight)");
    }

    private string GetBackendHttpUrl()
    {
        var backendUrl = "http://localhost:8000";
        var backendConfig = Configuration.GetSection("services:backend").GetChildren();
        foreach (var section in backendConfig)
        {
            var url = section.GetChildren().FirstOrDefault()?.Value;
            if (url != null && url.StartsWith("http://"))
            {
                backendUrl = url.TrimEnd('/');
                break;
            }
        }
        return backendUrl;
    }

    private async Task TestConnection()
    {
        LogDebug("--- Starting HTTP Connection Test ---");
        try
        {
            var backendUrl = GetBackendHttpUrl();
            LogDebug($"Testing HTTP connection to: {backendUrl}");
            
            // Use the injected HttpClientFactory to get the client configured with ServiceDefaults
            var client = HttpClientFactory.CreateClient("backend");

            // Test 1: Root endpoint
            LogDebug("1. Testing Root Endpoint (/)");
            var rootResponse = await client.GetAsync("/");
            LogDebug($"   Status: {(int)rootResponse.StatusCode} {rootResponse.StatusCode}");
            var rootContent = await rootResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {rootContent}");

            // Test 2: Ping endpoint
            LogDebug("2. Testing Ping Endpoint (/api/test/ping)");
            var pingResponse = await client.GetAsync("/api/test/ping");
            LogDebug($"   Status: {(int)pingResponse.StatusCode} {pingResponse.StatusCode}");
            var pingContent = await pingResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {pingContent}");

            // Test 3: Health endpoint
            LogDebug("3. Testing Health Endpoint (/api/health)");
            var healthResponse = await client.GetAsync("/api/health");
            LogDebug($"   Status: {(int)healthResponse.StatusCode} {healthResponse.StatusCode}");
            var healthContent = await healthResponse.Content.ReadAsStringAsync();
            LogDebug($"   Response: {healthContent}");

            LogDebug("--- HTTP Connection Test Complete ---");
        }
        catch (Exception ex)
        {
            LogDebug($"HTTP Test Failed: {ex.GetType().Name} - {ex.Message}");
            if (ex.InnerException != null)
            {
                LogDebug($"Inner exception: {ex.InnerException.Message}");
            }
        }
    }

    private async Task ConnectWebSocket()
    {
        if (isConnected || isConnecting) return;
        
        isConnecting = true;
        await InvokeAsync(StateHasChanged);
        
        try
        {
            LogDebug("Resolving backend URL from configuration...");
            // Resolve the actual backend URL from Aspire service discovery configuration.
            // ClientWebSocket doesn't go through HttpClient's service discovery pipeline,
            // so we read the resolved endpoint directly from configuration.
            
            // The backend has two endpoints: https and http.
            // We need to find the http one to avoid SSL certificate issues with wss://
            var backendUrl = GetBackendHttpUrl();
            
            LogDebug($"Resolved backend URL: {backendUrl}");

            var wsUrl = backendUrl.Replace("https://", "wss://").Replace("http://", "ws://");
            LogDebug($"WebSocket URL: {wsUrl}/ws/conversation");

            webSocket = new ClientWebSocket();
            cts = new CancellationTokenSource();

            LogDebug("Initiating WebSocket connection...");
            
            // Add a timeout to the WebSocket connection attempt
            using var connectCts = CancellationTokenSource.CreateLinkedTokenSource(cts.Token);
            connectCts.CancelAfter(TimeSpan.FromSeconds(30));
            
            await webSocket.ConnectAsync(new Uri($"{wsUrl}/ws/conversation"), connectCts.Token);
            isConnected = true;
            isConnecting = false;
            LogDebug("WebSocket connected successfully.");
            await InvokeAsync(StateHasChanged);

            _ = Task.Run(ReceiveLoop);
        }
        catch (Exception ex)
        {
            isConnecting = false;
            errorMessage = $"Connection failed: {ex.Message}. Retrying in 5s...";
            LogDebug($"Connection failed: {ex.GetType().Name} - {ex.Message}");
            if (ex.InnerException != null)
            {
                LogDebug($"Inner exception: {ex.InnerException.Message}");
            }
            isConnected = false;
            await InvokeAsync(StateHasChanged);
            
            await Task.Delay(5000);
            await ConnectWebSocket();
        }
    }

    private async Task ReceiveLoop()
    {
        var buffer = new byte[1024 * 64];
        try
        {
            while (webSocket?.State == WebSocketState.Open && cts is not null && !cts.IsCancellationRequested)
            {
                var result = await webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), cts.Token);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    LogDebug("WebSocket closed by server.");
                    isConnected = false;
                    await InvokeAsync(StateHasChanged);
                    break;
                }

                if (result.MessageType == WebSocketMessageType.Text)
                {
                    var json = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    await HandleTextMessage(json);
                }
                else if (result.MessageType == WebSocketMessageType.Binary)
                {
                    pendingAudioBytes.AddRange(new ArraySegment<byte>(buffer, 0, result.Count));
                }
            }
        }
        catch (OperationCanceledException) { }
        catch (WebSocketException ex)
        {
            isConnected = false;
            errorMessage = "WebSocket disconnected. Reconnecting...";
            LogDebug($"WebSocket exception: {ex.Message}. Reconnecting in 2s...");
            await InvokeAsync(StateHasChanged);
            await Task.Delay(2000);
            await ConnectWebSocket();
        }
    }

    private async Task HandleTextMessage(string json)
    {
        try
        {
            using var doc = JsonDocument.Parse(json);
            var type = doc.RootElement.GetProperty("type").GetString();

            switch (type)
            {
                case "transcript":
                    var userText = doc.RootElement.GetProperty("text").GetString() ?? "";
                    messages.Add(new ChatMessage { Text = userText, IsUser = true });
                    statusText = "Thinking...";
                    break;

                case "response":
                    var aiText = doc.RootElement.GetProperty("text").GetString() ?? "";
                    messages.Add(new ChatMessage { Text = aiText, IsUser = false });
                    statusText = "Speaking...";
                    break;

                case "audio_complete":
                    if (pendingAudioBytes.Count > 0)
                    {
                        var lastAiMsg = messages.LastOrDefault(m => !m.IsUser);
                        if (lastAiMsg != null)
                        {
                            lastAiMsg.HasAudio = true;
                            lastAiMsg.AudioBytes = pendingAudioBytes.ToArray();
                        }
                        // Auto-play the response audio
                        await JS.InvokeVoidAsync("audioInterop.playAudio", pendingAudioBytes.ToArray());
                        pendingAudioBytes.Clear();
                    }
                    statusText = null;
                    break;
            }

            await InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    private async Task StartRecording()
    {
        if (!isConnected || isRecording) return;

        try
        {
            await JS.InvokeVoidAsync("audioInterop.startRecording");
            isRecording = true;
            statusText = "Listening...";
        }
        catch (Exception ex)
        {
            errorMessage = $"Microphone access denied: {ex.Message}";
        }
    }

    private async Task StopRecording()
    {
        if (!isRecording) return;

        try
        {
            isRecording = false;
            statusText = "Processing...";
            StateHasChanged();

            var audioData = await JS.InvokeAsync<byte[]>("audioInterop.stopRecording");

            if (webSocket?.State == WebSocketState.Open && audioData?.Length > 0)
            {
                // Send audio binary frame
                await webSocket.SendAsync(
                    new ArraySegment<byte>(audioData),
                    WebSocketMessageType.Binary,
                    true,
                    cts?.Token ?? CancellationToken.None);

                // Send end_audio signal
                var endSignal = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(new { type = "end_of_speech" }));
                await webSocket.SendAsync(
                    new ArraySegment<byte>(endSignal),
                    WebSocketMessageType.Text,
                    true,
                    cts?.Token ?? CancellationToken.None);

                statusText = "Thinking...";
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to send audio: {ex.Message}";
            statusText = null;
        }
    }

    private async Task PlayAudio(byte[] audioBytes)
    {
        await JS.InvokeVoidAsync("audioInterop.playAudio", audioBytes);
    }

    public async ValueTask DisposeAsync()
    {
        cts?.Cancel();
        if (webSocket?.State == WebSocketState.Open)
        {
            try
            {
                await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
            }
            catch { }
        }
        webSocket?.Dispose();
        cts?.Dispose();
    }
}
